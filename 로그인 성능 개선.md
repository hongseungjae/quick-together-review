artillery를 이용하여 로그인 성능 테스트 결과이다.

```
errors.ETIMEDOUT: .............................................................. 193
http.codes.200: ................................................................ 117
http.request_rate: ............................................................. 20/sec
http.requests: ................................................................. 300
http.response_time:
  min: ......................................................................... 174
  max: ......................................................................... 9985
  median: ...................................................................... 8186.6
  p95: ......................................................................... 9801.2
  p99: ......................................................................... 9999.2
http.responses: ................................................................ 117
vusers.completed: .............................................................. 107
vusers.created: ................................................................ 300
vusers.created_by_name.Get projects: ........................................... 300
vusers.failed: ................................................................. 193
vusers.session_length:
  min: ......................................................................... 188.8
  max: ......................................................................... 9999.5
  median: ...................................................................... 7865.6
  p95: ......................................................................... 9801.2
  p99: ......................................................................... 9999.2
  ```
  
  15초 동안 초당 20유저가 들어오는데, request당 대략적으로 10초의 처리와 193개가 타임아웃 되었다.
  
  또한 cpu 사용량도 99%에 달하는 수치를 보이고 있다. 
  
  이 부분은 aws에 프리티어를 사용중이고 1cpu, 1core이기때문에 높게 측정될 수 있다고 생각한다.
  
  ![image](https://user-images.githubusercontent.com/41093183/229483781-1c7253dc-66e3-4688-a62b-cabef3e9b195.png)
  
그러면 어느 코드에서 이 부분이 잡아먹고 있는지 살펴봐야 할 것 같다.

아래가 로그인이 수행되는 로직이고, 간단한 세션 로그인 방식이다.
```
      public Long login(String memberName, String password) {
        Member member = memberRepository.findByMemberName(memberName)
                .orElseThrow(MemberNotFoundException::new);

        if (!passwordEncoder.matches(password,member.getPassword())) {
            throw new BadCredentialsException();
        }

        httpSession.setAttribute(SessionConst.LOGIN_MEMBER, member.getId());

        return member.getId();
    }
```

멤버 이름을 찾고, 비밀번호를 검증하고, 세션에 로그인 ID를 저장시키는 로직으로 불필요하거나 문제의 소지가 될만한 로직은 보이지 않는다.

코드상에도 별문제가 보이지 않아서, 실제 테스트 도중에 어떤 로직이 돌아가는지, 어떤 코드가 많이 cpu를 먹고 있는지 살펴볼 필요가 있어서 쓰레드 덤프 떴다.

쓰레드 덤프는 프로세스의 단면으로 현재 쓰레드의 상태를 볼 수 있다. 그 순간의 동작만 볼 수 있기때문에 3초정도 간격을 두고 연속적으로 뜰 필요가 있다.

쓰레드 덤프 뜨는 순간에 실행중이던 쓰레드들이다.
![image](https://user-images.githubusercontent.com/41093183/229487713-08baa736-e125-4765-80f7-fbd6a41da450.png)

cpu를 많이 쓰는 쓰레드들이다.
![image](https://user-images.githubusercontent.com/41093183/229488042-ce40f2e3-189d-428e-82ea-ecdfee9cdb46.png)

두번째 결과이다.
![image](https://user-images.githubusercontent.com/41093183/229488403-cb15cf88-49d6-460a-8f2d-bbbf73ae660f.png)
![image](https://user-images.githubusercontent.com/41093183/229488594-f3a8635f-7ea7-4e1d-a8ee-e38abf96ab5f.png)


요청이 들어와서 처리하는 http 쓰레드들을 보면 org.springframework.security.crypto.bcrypt.BCrypt 클래스가 많이 보인다.

해당 부분에 StackTrace 결과이다.
![image](https://user-images.githubusercontent.com/41093183/229489260-b9e0b4c2-010e-41c6-a577-fc6d1a6c678f.png)

login 메서드 실행 이후에 BCryptPasswordEncoder클래스에 matches 메서드를 실행시키는 부분이다.
```
at org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder.matches(BCryptPasswordEncoder.java:133)
at com.flab.quicktogether.member.application.login.SessionLoginService.login(SessionLoginService.java:36)
```

실제 코드와 매칭 시켜보면 여기서 시작이다.
```
if (!passwordEncoder.matches(password,member.getPassword())) {
            throw new BadCredentialsException();
}
```

즉, 패스워드 Encoder 과정중에서 지연이 발생하였다. 확실히 하기위해서 해당 코드를 제거하고 테스트 해보면 빠르게 처리가 된다.
```
http.codes.200: ................................................................ 450
http.request_rate: ............................................................. 30/sec
http.requests: ................................................................. 450
http.response_time:
  min: ......................................................................... 5
  max: ......................................................................... 20
  median: ...................................................................... 7
  p95: ......................................................................... 13.9
  p99: ......................................................................... 16.9
http.responses: ................................................................ 450
vusers.completed: .............................................................. 450
vusers.created: ................................................................ 450
vusers.created_by_name.Get projects: ........................................... 450
vusers.failed: ................................................................. 0
vusers.session_length:
  min: ......................................................................... 9.2
  max: ......................................................................... 43.4
  median: ...................................................................... 13.1
  p95: ......................................................................... 24.3
  p99: ......................................................................... 35.5
Log file: resultLogin.json
```

패스워드 인코더 과정은 보안상 사용하지 않을 수 없기때문에 개선을 해야한다.

현재 사용중인 인코더 클래스는 BCryptPasswordEncoder 이다. 

관련하여 찾아보면 성능 이슈들이 존재하고 있었다.

https://stackoverflow.com/questions/51777464/why-is-spring-boot-security-basic-authentication-slow

간단하게 해싱 알고리즘 횟수를 조정할 수 있다. 

기본 값이 10으로 4로 설정한 뒤에 테스트 진행하였다.

```
http.codes.200: ................................................................ 300
http.request_rate: ............................................................. 20/sec
http.requests: ................................................................. 300
http.response_time:
  min: ......................................................................... 7
  max: ......................................................................... 44
  median: ...................................................................... 10.1
  p95: ......................................................................... 16
  p99: ......................................................................... 22.9
http.responses: ................................................................ 300
vusers.completed: .............................................................. 300
vusers.created: ................................................................ 300
vusers.created_by_name.Get projects: ........................................... 300
vusers.failed: ................................................................. 0
vusers.session_length:
  min: ......................................................................... 11
  max: ......................................................................... 55.8
  median: ...................................................................... 16
  p95: ......................................................................... 35.5
  p99: ......................................................................... 45.2
Log file: resultLogin.json
```

![image](https://user-images.githubusercontent.com/41093183/229578087-5c7fbd81-9492-481b-af31-49dc9e8752dc.png)

똑같은 조건으로 테스트한 결과 모든 request가 정상적으로 처리되었으며 평균 0.01초 걸려서 월등히 향상되었다.

또한 cpu사용률도 많이 낮아졌다.

보안에 비중을 좀 낮추고 성능을 끌어올린 케이스이다. 해싱 횟수나 어떤 알고리즘을 사용할 것인지, 또한 프로젝트 사양마다 다를것이므로 맞게 설정해주면 된다.

